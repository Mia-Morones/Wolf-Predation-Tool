{"version":3,"file":"3668.9b2c69e4040f32c724c7.js","mappings":"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","sources":["webpack://react-redux-arcgis-boilerplate/./node_modules/@esri/calcite-components/dist/components/Heading.js","webpack://react-redux-arcgis-boilerplate/./node_modules/@esri/calcite-components/dist/components/action-menu.js","webpack://react-redux-arcgis-boilerplate/./node_modules/@esri/calcite-components/dist/components/focusTrapComponent.js","webpack://react-redux-arcgis-boilerplate/./node_modules/@esri/calcite-components/dist/components/popover.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nimport { h } from '@stencil/core/internal/client';\n\nfunction constrainHeadingLevel(level) {\n    return Math.min(Math.max(Math.ceil(level), 1), 6);\n}\nconst Heading = (props, children) => {\n    const HeadingTag = props.level ? `h${props.level}` : \"div\";\n    delete props.level;\n    return (h(HeadingTag, { class: props.class, key: props.key }, children));\n};\n\nexport { Heading as H, constrainHeadingLevel as c };\n\n//# sourceMappingURL=Heading.js.map","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Fragment } from '@stencil/core/internal/client';\nimport { g as getRoundRobinIndex } from './array.js';\nimport { t as toAriaBoolean, e as focusElement } from './dom.js';\nimport { g as guid } from './guid.js';\nimport { i as isActivationKey } from './key.js';\nimport { s as setUpLoadableComponent, a as setComponentLoaded, c as componentFocusable } from './loadable.js';\nimport { d as defineCustomElement$4 } from './action.js';\nimport { d as defineCustomElement$3 } from './icon.js';\nimport { d as defineCustomElement$2 } from './loader.js';\nimport { d as defineCustomElement$1 } from './popover.js';\n\nconst CSS = {\n    menu: \"menu\",\n    defaultTrigger: \"default-trigger\",\n};\nconst SLOTS = {\n    tooltip: \"tooltip\",\n    trigger: \"trigger\",\n};\nconst ICONS = {\n    menu: \"ellipsis\",\n};\nconst activeAttr = \"data-active\";\n\nconst actionMenuCss = \":host{box-sizing:border-box;display:flex;flex-direction:column;font-size:var(--calcite-font-size-1)}::slotted(calcite-action-group:not(:last-of-type)){border-block-end-width:var(--calcite-border-width-sm)}.default-trigger{position:relative;block-size:100%;flex:0 1 auto;align-self:stretch}slot[name=trigger]::slotted(calcite-action),calcite-action::slotted([slot=trigger]){position:relative;block-size:100%;flex:0 1 auto;align-self:stretch}.menu{display:flex;max-block-size:45vh;flex-direction:column;flex-wrap:nowrap;overflow-y:auto;overflow-x:hidden;outline:2px solid transparent;outline-offset:2px;gap:var(--calcite-action-menu-items-space, 0)}:host([hidden]){display:none}[hidden]{display:none}\";\nconst CalciteActionMenuStyle0 = actionMenuCss;\n\nconst SUPPORTED_MENU_NAV_KEYS = [\"ArrowUp\", \"ArrowDown\", \"End\", \"Home\"];\nconst ActionMenu = /*@__PURE__*/ proxyCustomElement(class ActionMenu extends HTMLElement {\n    constructor() {\n        super();\n        this.__registerHost();\n        this.__attachShadow();\n        this.calciteActionMenuOpen = createEvent(this, \"calciteActionMenuOpen\", 6);\n        this.actionElements = [];\n        this.guid = `calcite-action-menu-${guid()}`;\n        this.menuId = `${this.guid}-menu`;\n        this.menuButtonId = `${this.guid}-menu-button`;\n        // --------------------------------------------------------------------------\n        //\n        //  Component Methods\n        //\n        // --------------------------------------------------------------------------\n        this.connectMenuButtonEl = () => {\n            const { menuButtonId, menuId, open, label } = this;\n            const menuButtonEl = this.slottedMenuButtonEl || this.defaultMenuButtonEl;\n            if (this.menuButtonEl === menuButtonEl) {\n                return;\n            }\n            this.disconnectMenuButtonEl();\n            this.menuButtonEl = menuButtonEl;\n            this.setTooltipReferenceElement();\n            if (!menuButtonEl) {\n                return;\n            }\n            menuButtonEl.active = open;\n            menuButtonEl.setAttribute(\"aria-controls\", menuId);\n            menuButtonEl.setAttribute(\"aria-expanded\", toAriaBoolean(open));\n            menuButtonEl.setAttribute(\"aria-haspopup\", \"true\");\n            if (!menuButtonEl.id) {\n                menuButtonEl.id = menuButtonId;\n            }\n            if (!menuButtonEl.label) {\n                menuButtonEl.label = label;\n            }\n            if (!menuButtonEl.text) {\n                menuButtonEl.text = label;\n            }\n            menuButtonEl.addEventListener(\"click\", this.menuButtonClick);\n            menuButtonEl.addEventListener(\"keydown\", this.menuButtonKeyDown);\n        };\n        this.disconnectMenuButtonEl = () => {\n            const { menuButtonEl } = this;\n            if (!menuButtonEl) {\n                return;\n            }\n            menuButtonEl.removeEventListener(\"click\", this.menuButtonClick);\n            menuButtonEl.removeEventListener(\"keydown\", this.menuButtonKeyDown);\n        };\n        this.setMenuButtonEl = (event) => {\n            const actions = event.target\n                .assignedElements({\n                flatten: true,\n            })\n                .filter((el) => el?.matches(\"calcite-action\"));\n            this.slottedMenuButtonEl = actions[0];\n            this.connectMenuButtonEl();\n        };\n        this.setDefaultMenuButtonEl = (el) => {\n            this.defaultMenuButtonEl = el;\n            this.connectMenuButtonEl();\n        };\n        // --------------------------------------------------------------------------\n        //\n        //  Private Methods\n        //\n        // --------------------------------------------------------------------------\n        this.handleCalciteActionClick = () => {\n            this.open = false;\n            this.setFocus();\n        };\n        this.menuButtonClick = () => {\n            this.toggleOpen();\n        };\n        this.updateTooltip = (event) => {\n            const tooltips = event.target\n                .assignedElements({\n                flatten: true,\n            })\n                .filter((el) => el?.matches(\"calcite-tooltip\"));\n            this.tooltipEl = tooltips[0];\n            this.setTooltipReferenceElement();\n        };\n        this.setTooltipReferenceElement = () => {\n            const { tooltipEl, expanded, menuButtonEl, open } = this;\n            if (tooltipEl) {\n                tooltipEl.referenceElement = !expanded && !open ? menuButtonEl : null;\n            }\n        };\n        this.updateAction = (action, index) => {\n            const { guid, activeMenuItemIndex } = this;\n            const id = `${guid}-action-${index}`;\n            action.tabIndex = -1;\n            action.setAttribute(\"role\", \"menuitem\");\n            if (!action.id) {\n                action.id = id;\n            }\n            // data attribute is used to style the \"activeMenuItemIndex\" action using token focus styling.\n            action.toggleAttribute(activeAttr, index === activeMenuItemIndex);\n        };\n        this.updateActions = (actions) => {\n            actions?.forEach(this.updateAction);\n        };\n        this.handleDefaultSlotChange = (event) => {\n            const actions = event.target\n                .assignedElements({\n                flatten: true,\n            })\n                .reduce((previousValue, currentValue) => {\n                if (currentValue?.matches(\"calcite-action\")) {\n                    previousValue.push(currentValue);\n                    return previousValue;\n                }\n                if (currentValue?.matches(\"calcite-action-group\")) {\n                    return previousValue.concat(Array.from(currentValue.querySelectorAll(\"calcite-action\")));\n                }\n                return previousValue;\n            }, []);\n            this.actionElements = actions.filter((action) => !action.disabled && !action.hidden);\n        };\n        this.menuButtonKeyDown = (event) => {\n            const { key } = event;\n            const { actionElements, activeMenuItemIndex, open } = this;\n            if (!actionElements.length) {\n                return;\n            }\n            if (isActivationKey(key)) {\n                event.preventDefault();\n                if (!open) {\n                    this.toggleOpen();\n                    return;\n                }\n                const action = actionElements[activeMenuItemIndex];\n                action ? action.click() : this.toggleOpen(false);\n            }\n            if (key === \"Tab\") {\n                this.open = false;\n                return;\n            }\n            if (key === \"Escape\") {\n                this.toggleOpen(false);\n                event.preventDefault();\n                return;\n            }\n            this.handleActionNavigation(event, key, actionElements);\n        };\n        this.handleActionNavigation = (event, key, actions) => {\n            if (!this.isValidKey(key, SUPPORTED_MENU_NAV_KEYS)) {\n                return;\n            }\n            event.preventDefault();\n            if (!this.open) {\n                this.toggleOpen();\n                if (key === \"Home\" || key === \"ArrowDown\") {\n                    this.activeMenuItemIndex = 0;\n                }\n                if (key === \"End\" || key === \"ArrowUp\") {\n                    this.activeMenuItemIndex = actions.length - 1;\n                }\n                return;\n            }\n            if (key === \"Home\") {\n                this.activeMenuItemIndex = 0;\n            }\n            if (key === \"End\") {\n                this.activeMenuItemIndex = actions.length - 1;\n            }\n            const currentIndex = this.activeMenuItemIndex;\n            if (key === \"ArrowUp\") {\n                this.activeMenuItemIndex = getRoundRobinIndex(Math.max(currentIndex - 1, -1), actions.length);\n            }\n            if (key === \"ArrowDown\") {\n                this.activeMenuItemIndex = getRoundRobinIndex(currentIndex + 1, actions.length);\n            }\n        };\n        this.toggleOpenEnd = () => {\n            this.setFocus();\n            this.el.removeEventListener(\"calcitePopoverOpen\", this.toggleOpenEnd);\n        };\n        this.toggleOpen = (value = !this.open) => {\n            this.el.addEventListener(\"calcitePopoverOpen\", this.toggleOpenEnd);\n            this.open = value;\n        };\n        this.handlePopoverOpen = () => {\n            this.open = true;\n        };\n        this.handlePopoverClose = () => {\n            this.open = false;\n        };\n        this.appearance = \"solid\";\n        this.expanded = false;\n        this.flipPlacements = undefined;\n        this.label = undefined;\n        this.open = false;\n        this.overlayPositioning = \"absolute\";\n        this.placement = \"auto\";\n        this.scale = undefined;\n        this.menuButtonEl = undefined;\n        this.activeMenuItemIndex = -1;\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Lifecycle\n    //\n    // --------------------------------------------------------------------------\n    connectedCallback() {\n        this.connectMenuButtonEl();\n    }\n    componentWillLoad() {\n        setUpLoadableComponent(this);\n    }\n    componentDidLoad() {\n        setComponentLoaded(this);\n    }\n    disconnectedCallback() {\n        this.disconnectMenuButtonEl();\n    }\n    expandedHandler() {\n        this.open = false;\n        this.setTooltipReferenceElement();\n    }\n    openHandler(open) {\n        this.activeMenuItemIndex = this.open ? 0 : -1;\n        if (this.menuButtonEl) {\n            this.menuButtonEl.active = open;\n        }\n        this.calciteActionMenuOpen.emit();\n        this.setTooltipReferenceElement();\n    }\n    activeMenuItemIndexHandler() {\n        this.updateActions(this.actionElements);\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Methods\n    //\n    // --------------------------------------------------------------------------\n    /** Sets focus on the component. */\n    async setFocus() {\n        await componentFocusable(this);\n        return focusElement(this.menuButtonEl);\n    }\n    renderMenuButton() {\n        const { appearance, label, scale, expanded } = this;\n        const menuButtonSlot = (h(\"slot\", { name: SLOTS.trigger, onSlotchange: this.setMenuButtonEl }, h(\"calcite-action\", { appearance: appearance, class: CSS.defaultTrigger, icon: ICONS.menu, ref: this.setDefaultMenuButtonEl, scale: scale, text: label, textEnabled: expanded })));\n        return menuButtonSlot;\n    }\n    renderMenuItems() {\n        const { actionElements, activeMenuItemIndex, open, menuId, menuButtonEl, label, placement, overlayPositioning, flipPlacements, } = this;\n        const activeAction = actionElements[activeMenuItemIndex];\n        const activeDescendantId = activeAction?.id || null;\n        return (h(\"calcite-popover\", { autoClose: true, flipPlacements: flipPlacements, focusTrapDisabled: true, label: label, offsetDistance: 0, onCalcitePopoverClose: this.handlePopoverClose, onCalcitePopoverOpen: this.handlePopoverOpen, open: open, overlayPositioning: overlayPositioning, placement: placement, pointerDisabled: true, referenceElement: menuButtonEl }, h(\"div\", { \"aria-activedescendant\": activeDescendantId, \"aria-labelledby\": menuButtonEl?.id, class: CSS.menu, id: menuId, onClick: this.handleCalciteActionClick, role: \"menu\", tabIndex: -1 }, h(\"slot\", { onSlotchange: this.handleDefaultSlotChange }))));\n    }\n    render() {\n        return (h(Fragment, { key: 'd13aa4f3d43fb5651c0487ccfa456813f69955d2' }, this.renderMenuButton(), this.renderMenuItems(), h(\"slot\", { key: 'b63d187516c766db6a1b1db3df34050fdec9e6ce', name: SLOTS.tooltip, onSlotchange: this.updateTooltip })));\n    }\n    isValidKey(key, supportedKeys) {\n        return !!supportedKeys.find((k) => k === key);\n    }\n    get el() { return this; }\n    static get watchers() { return {\n        \"expanded\": [\"expandedHandler\"],\n        \"open\": [\"openHandler\"],\n        \"activeMenuItemIndex\": [\"activeMenuItemIndexHandler\"]\n    }; }\n    static get style() { return CalciteActionMenuStyle0; }\n}, [1, \"calcite-action-menu\", {\n        \"appearance\": [513],\n        \"expanded\": [516],\n        \"flipPlacements\": [16],\n        \"label\": [1],\n        \"open\": [1540],\n        \"overlayPositioning\": [513, \"overlay-positioning\"],\n        \"placement\": [513],\n        \"scale\": [513],\n        \"menuButtonEl\": [32],\n        \"activeMenuItemIndex\": [32],\n        \"setFocus\": [64]\n    }, undefined, {\n        \"expanded\": [\"expandedHandler\"],\n        \"open\": [\"openHandler\"],\n        \"activeMenuItemIndex\": [\"activeMenuItemIndexHandler\"]\n    }]);\nfunction defineCustomElement() {\n    if (typeof customElements === \"undefined\") {\n        return;\n    }\n    const components = [\"calcite-action-menu\", \"calcite-action\", \"calcite-icon\", \"calcite-loader\", \"calcite-popover\"];\n    components.forEach(tagName => { switch (tagName) {\n        case \"calcite-action-menu\":\n            if (!customElements.get(tagName)) {\n                customElements.define(tagName, ActionMenu);\n            }\n            break;\n        case \"calcite-action\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$4();\n            }\n            break;\n        case \"calcite-icon\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$3();\n            }\n            break;\n        case \"calcite-loader\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$2();\n            }\n            break;\n        case \"calcite-popover\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$1();\n            }\n            break;\n    } });\n}\ndefineCustomElement();\n\nexport { ActionMenu as A, SLOTS as S, defineCustomElement as d };\n\n//# sourceMappingURL=action-menu.js.map","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nimport { h as isFocusable, j as tabbable, k as focusable, l as isTabbable, m as getTabIndex, e as focusElement, n as tabbableOptions } from './dom.js';\nimport { f as focusTrapStack } from './config.js';\n\n/*!\n* focus-trap 7.6.0\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n    return true; // next\n  });\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || ( // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      optionValue = optionValue.apply(void 0, params);\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  var _getActiveElement = function getActiveElement(el) {\n    var activeElement = el.activeElement;\n    if (!activeElement) {\n      return;\n    }\n    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {\n      return _getActiveElement(activeElement.shadowRoot);\n    }\n    return activeElement;\n  };\n  var _tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === _getActiveElement(document)) {\n      return;\n    }\n    if (!node || !node.focus) {\n      _tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref2) {\n    var target = _ref2.target,\n      event = _ref2.event,\n      _ref2$isBackward = _ref2.isBackward,\n      isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var firstTabbableNode = _ref3.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref4) {\n          var lastTabbableNode = _ref4.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        _tryFocus(nextNode);\n      } else {\n        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      _tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n  var checkTabKey = function checkTabKey(event) {\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n\n  // we use a different event phase for the Escape key to allow canceling the event and checking for this in escapeDeactivates\n  var checkEscapeKey = function checkEscapeKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      _tryFocus(getInitialFocusNode());\n    }) : _tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkTabKey, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkTabKey, true);\n    doc.removeEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      _tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      onActivate === null || onActivate === void 0 || onActivate();\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate === null || onPostActivate === void 0 || onPostActivate();\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === void 0 || onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (state.paused || !state.active) {\n        return this;\n      }\n      var onPause = getOption(pauseOptions, 'onPause');\n      var onPostPause = getOption(pauseOptions, 'onPostPause');\n      state.paused = true;\n      onPause === null || onPause === void 0 || onPause();\n      removeListeners();\n      updateObservedNodes();\n      onPostPause === null || onPostPause === void 0 || onPostPause();\n      return this;\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n      var onUnpause = getOption(unpauseOptions, 'onUnpause');\n      var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');\n      state.paused = false;\n      onUnpause === null || onUnpause === void 0 || onUnpause();\n      updateTabbableNodes();\n      addListeners();\n      updateObservedNodes();\n      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\n/**\n * Helper to set up the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param options\n */\nfunction connectFocusTrap(component, options) {\n    const { el } = component;\n    const focusTrapNode = options?.focusTrapEl || el;\n    if (!focusTrapNode) {\n        return;\n    }\n    const focusTrapOptions = {\n        clickOutsideDeactivates: true,\n        escapeDeactivates: false,\n        fallbackFocus: focusTrapNode,\n        setReturnFocus: (el) => {\n            focusElement(el);\n            return false;\n        },\n        ...options?.focusTrapOptions,\n        // the following options are not overridable\n        document: el.ownerDocument,\n        tabbableOptions,\n        trapStack: focusTrapStack,\n    };\n    component.focusTrap = createFocusTrap(focusTrapNode, focusTrapOptions);\n}\n/**\n * Helper to activate the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param [options] The FocusTrap activate options.\n */\nfunction activateFocusTrap(component, options) {\n    if (!component.focusTrapDisabled) {\n        component.focusTrap?.activate(options);\n    }\n}\n/**\n * Helper to deactivate the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param [options] The FocusTrap deactivate options.\n */\nfunction deactivateFocusTrap(component, options) {\n    component.focusTrap?.deactivate(options);\n}\n/**\n * Helper to update the element(s) that are used within the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @example\n * const modal = document.querySelector(\"calcite-modal\");\n * const input = document.createElement(\"calcite-input\");\n * content.appendChild(input);\n * await input.componentOnReady();\n * await modal.updateFocusTrapElements();\n * requestAnimationFrame(() => input.setFocus());\n */\nfunction updateFocusTrapElements(component) {\n    component.focusTrap?.updateContainerElements(component.el);\n}\n\nexport { activateFocusTrap as a, connectFocusTrap as c, deactivateFocusTrap as d, updateFocusTrapElements as u };\n\n//# sourceMappingURL=focusTrapComponent.js.map","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/dev/LICENSE.md for details.\n * v2.13.2\n */\nimport { proxyCustomElement, HTMLElement, createEvent, forceUpdate, h, Host } from '@stencil/core/internal/client';\nimport { f as filterValidFlipPlacements, c as connectFloatingUI, d as defaultOffsetDistance, a as disconnectFloatingUI, r as reposition, F as FloatingCSS } from './floating-ui.js';\nimport { d as deactivateFocusTrap, a as activateFocusTrap, c as connectFocusTrap, u as updateFocusTrapElements } from './focusTrapComponent.js';\nimport { i as isKeyboardTriggeredClick, t as toAriaBoolean, f as focusFirstTabbable, q as queryElementRoots } from './dom.js';\nimport { g as guid } from './guid.js';\nimport { o as onToggleOpenCloseComponent } from './openCloseComponent.js';\nimport { H as Heading } from './Heading.js';\nimport { c as connectLocalized, d as disconnectLocalized } from './locale.js';\nimport { u as updateMessages, c as connectMessages, s as setUpMessages, d as disconnectMessages } from './t9n.js';\nimport { s as setUpLoadableComponent, a as setComponentLoaded, c as componentFocusable } from './loadable.js';\nimport { c as createObserver } from './observers.js';\nimport { F as FloatingArrow } from './FloatingArrow.js';\nimport { g as getIconScale } from './component.js';\nimport { i as isActivationKey } from './key.js';\nimport { d as defineCustomElement$3 } from './action.js';\nimport { d as defineCustomElement$2 } from './icon.js';\nimport { d as defineCustomElement$1 } from './loader.js';\n\nclass PopoverManager {\n    constructor() {\n        // --------------------------------------------------------------------------\n        //\n        //  Private Properties\n        //\n        // --------------------------------------------------------------------------\n        this.registeredElements = new Map();\n        this.registeredElementCount = 0;\n        // --------------------------------------------------------------------------\n        //\n        //  Private Methods\n        //\n        // --------------------------------------------------------------------------\n        this.queryPopover = (composedPath) => {\n            const { registeredElements } = this;\n            const registeredElement = composedPath.find((pathEl) => registeredElements.has(pathEl));\n            return registeredElements.get(registeredElement);\n        };\n        this.togglePopovers = (event) => {\n            const composedPath = event.composedPath();\n            const togglePopover = this.queryPopover(composedPath);\n            if (togglePopover && !togglePopover.triggerDisabled) {\n                togglePopover.open = !togglePopover.open;\n            }\n            Array.from(this.registeredElements.values())\n                .filter((popover) => popover !== togglePopover && popover.autoClose && popover.open && !composedPath.includes(popover))\n                .forEach((popover) => (popover.open = false));\n        };\n        this.keyDownHandler = (event) => {\n            if (event.defaultPrevented) {\n                return;\n            }\n            if (event.key === \"Escape\") {\n                this.closeAllPopovers();\n            }\n            else if (isActivationKey(event.key)) {\n                this.togglePopovers(event);\n            }\n        };\n        this.clickHandler = (event) => {\n            if (isKeyboardTriggeredClick(event)) {\n                return;\n            }\n            this.togglePopovers(event);\n        };\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Public Methods\n    //\n    // --------------------------------------------------------------------------\n    registerElement(referenceEl, popover) {\n        this.registeredElementCount++;\n        this.registeredElements.set(referenceEl, popover);\n        if (this.registeredElementCount === 1) {\n            this.addListeners();\n        }\n    }\n    unregisterElement(referenceEl) {\n        if (this.registeredElements.delete(referenceEl)) {\n            this.registeredElementCount--;\n        }\n        if (this.registeredElementCount === 0) {\n            this.removeListeners();\n        }\n    }\n    closeAllPopovers() {\n        Array.from(this.registeredElements.values()).forEach((popover) => (popover.open = false));\n    }\n    addListeners() {\n        window.addEventListener(\"click\", this.clickHandler);\n        window.addEventListener(\"keydown\", this.keyDownHandler);\n    }\n    removeListeners() {\n        window.removeEventListener(\"click\", this.clickHandler);\n        window.removeEventListener(\"keydown\", this.keyDownHandler);\n    }\n}\n\nconst CSS = {\n    container: \"container\",\n    imageContainer: \"image-container\",\n    closeButtonContainer: \"close-button-container\",\n    closeButton: \"close-button\",\n    content: \"content\",\n    hasHeader: \"has-header\",\n    header: \"header\",\n    headerContainer: \"headerContainer\",\n    headerContent: \"header-content\",\n    heading: \"heading\",\n};\nconst defaultPopoverPlacement = \"auto\";\nconst ARIA_CONTROLS = \"aria-controls\";\nconst ARIA_EXPANDED = \"aria-expanded\";\n\nconst popoverCss = \":host{--calcite-floating-ui-z-index:var(--calcite-popover-z-index, var(--calcite-z-index-popup));display:block;position:absolute;z-index:var(--calcite-floating-ui-z-index)}.calcite-floating-ui-anim{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:inset, left, opacity;opacity:0;box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:var(--calcite-z-index);border-radius:0.25rem}:host([data-placement^=bottom]) .calcite-floating-ui-anim{inset-block-start:-5px}:host([data-placement^=top]) .calcite-floating-ui-anim{inset-block-start:5px}:host([data-placement^=left]) .calcite-floating-ui-anim{left:5px}:host([data-placement^=right]) .calcite-floating-ui-anim{left:-5px}:host([data-placement]) .calcite-floating-ui-anim--active{opacity:1;inset-block:0;left:0}:host([calcite-hydrated-hidden]){visibility:hidden !important;pointer-events:none}.calcite-floating-ui-arrow{pointer-events:none;position:absolute;z-index:calc(var(--calcite-z-index) * -1);fill:var(--calcite-color-foreground-1)}.calcite-floating-ui-arrow__stroke{stroke:var(--calcite-color-border-3)}:host([scale=s]) .heading{padding-inline:0.75rem;padding-block:0.5rem;font-size:var(--calcite-font-size--1);line-height:1.375}:host([scale=m]) .heading{padding-inline:1rem;padding-block:0.75rem;font-size:var(--calcite-font-size-0);line-height:1.375}:host([scale=l]) .heading{padding-inline:1.25rem;padding-block:1rem;font-size:var(--calcite-font-size-1);line-height:1.375}:host{pointer-events:none}:host([open]){pointer-events:initial}.calcite-floating-ui-anim{border-width:1px;border-style:solid;background-color:var(--calcite-popover-background-color, var(--calcite-color-foreground-1));border-color:var(--calcite-popover-border-color, var(--calcite-color-border-3));border-radius:var(--calcite-popover-corner-radius, var(--calcite-corner-radius-round))}.calcite-floating-ui-arrow{fill:var(--calcite-popover-background-color, var(--calcite-color-foreground-1))}.calcite-floating-ui-arrow__stroke{stroke:var(--calcite-popover-border-color, var(--calcite-color-border-3))}.header{display:flex;flex:1 1 auto;align-items:stretch;justify-content:flex-start;border-width:0px;border-block-end-width:1px;border-style:solid;border-block-end-color:var(--calcite-popover-border-color, var(--calcite-color-border-3))}.heading{margin:0px;display:block;flex:1 1 auto;align-self:center;white-space:normal;font-weight:var(--calcite-font-weight-medium);word-wrap:break-word;word-break:break-word;color:var(--calcite-popover-text-color, var(--calcite-color-text-1))}.headerContainer{position:relative;display:flex;block-size:100%;flex-direction:row;flex-wrap:nowrap;border-radius:0.25rem;color:var(--calcite-popover-text-color, var(--calcite-color-text-1))}.headerContainer.has-header{flex-direction:column}.content{display:flex;block-size:100%;inline-size:100%;flex-direction:column;flex-wrap:nowrap;align-self:center;word-wrap:break-word;word-break:break-word}.close-button-container{display:flex;overflow:hidden;flex:0 0 auto;border-start-end-radius:var(--calcite-popover-corner-radius, var(--calcite-corner-radius-round));border-end-end-radius:var(--calcite-popover-corner-radius, var(--calcite-corner-radius-round));--calcite-action-corner-radius-start-end:var(--calcite-popover-corner-radius, var(--calcite-corner-radius-sharp));--calcite-action-corner-radius-end-end:var(--calcite-popover-corner-radius, var(--calcite-corner-radius-sharp))}::slotted(calcite-panel),::slotted(calcite-flow){block-size:100%}:host([hidden]){display:none}[hidden]{display:none}\";\nconst CalcitePopoverStyle0 = popoverCss;\n\nconst manager = new PopoverManager();\nconst Popover = /*@__PURE__*/ proxyCustomElement(class Popover extends HTMLElement {\n    constructor() {\n        super();\n        this.__registerHost();\n        this.__attachShadow();\n        this.calcitePopoverBeforeClose = createEvent(this, \"calcitePopoverBeforeClose\", 6);\n        this.calcitePopoverClose = createEvent(this, \"calcitePopoverClose\", 6);\n        this.calcitePopoverBeforeOpen = createEvent(this, \"calcitePopoverBeforeOpen\", 6);\n        this.calcitePopoverOpen = createEvent(this, \"calcitePopoverOpen\", 6);\n        this.mutationObserver = createObserver(\"mutation\", () => this.updateFocusTrapElements());\n        this.guid = `calcite-popover-${guid()}`;\n        this.openTransitionProp = \"opacity\";\n        this.hasLoaded = false;\n        // --------------------------------------------------------------------------\n        //\n        //  Private Methods\n        //\n        // --------------------------------------------------------------------------\n        this.setTransitionEl = (el) => {\n            this.transitionEl = el;\n        };\n        this.setFilteredPlacements = () => {\n            const { el, flipPlacements } = this;\n            this.filteredFlipPlacements = flipPlacements\n                ? filterValidFlipPlacements(flipPlacements, el)\n                : null;\n        };\n        this.setUpReferenceElement = (warn = true) => {\n            this.removeReferences();\n            this.effectiveReferenceElement = this.getReferenceElement();\n            connectFloatingUI(this, this.effectiveReferenceElement, this.el);\n            const { el, referenceElement, effectiveReferenceElement } = this;\n            if (warn && referenceElement && !effectiveReferenceElement) {\n                console.warn(`${el.tagName}: reference-element id \"${referenceElement}\" was not found.`, {\n                    el,\n                });\n            }\n            this.addReferences();\n        };\n        this.getId = () => {\n            return this.el.id || this.guid;\n        };\n        this.setExpandedAttr = () => {\n            const { effectiveReferenceElement, open } = this;\n            if (!effectiveReferenceElement) {\n                return;\n            }\n            if (\"setAttribute\" in effectiveReferenceElement) {\n                effectiveReferenceElement.setAttribute(ARIA_EXPANDED, toAriaBoolean(open));\n            }\n        };\n        this.addReferences = () => {\n            const { effectiveReferenceElement } = this;\n            if (!effectiveReferenceElement) {\n                return;\n            }\n            const id = this.getId();\n            if (\"setAttribute\" in effectiveReferenceElement) {\n                effectiveReferenceElement.setAttribute(ARIA_CONTROLS, id);\n            }\n            manager.registerElement(effectiveReferenceElement, this.el);\n            this.setExpandedAttr();\n        };\n        this.removeReferences = () => {\n            const { effectiveReferenceElement } = this;\n            if (!effectiveReferenceElement) {\n                return;\n            }\n            if (\"removeAttribute\" in effectiveReferenceElement) {\n                effectiveReferenceElement.removeAttribute(ARIA_CONTROLS);\n                effectiveReferenceElement.removeAttribute(ARIA_EXPANDED);\n            }\n            manager.unregisterElement(effectiveReferenceElement);\n        };\n        this.hide = () => {\n            this.open = false;\n        };\n        this.storeArrowEl = (el) => {\n            this.arrowEl = el;\n            this.reposition(true);\n        };\n        this.autoClose = false;\n        this.closable = false;\n        this.flipDisabled = false;\n        this.focusTrapDisabled = false;\n        this.pointerDisabled = false;\n        this.flipPlacements = undefined;\n        this.heading = undefined;\n        this.headingLevel = undefined;\n        this.label = undefined;\n        this.messageOverrides = undefined;\n        this.messages = undefined;\n        this.offsetDistance = defaultOffsetDistance;\n        this.offsetSkidding = 0;\n        this.open = false;\n        this.overlayPositioning = \"absolute\";\n        this.placement = defaultPopoverPlacement;\n        this.referenceElement = undefined;\n        this.scale = \"m\";\n        this.triggerDisabled = false;\n        this.effectiveLocale = \"\";\n        this.floatingLayout = \"vertical\";\n        this.effectiveReferenceElement = undefined;\n        this.defaultMessages = undefined;\n    }\n    handleFocusTrapDisabled(focusTrapDisabled) {\n        if (!this.open) {\n            return;\n        }\n        focusTrapDisabled ? deactivateFocusTrap(this) : activateFocusTrap(this);\n    }\n    flipPlacementsHandler() {\n        this.setFilteredPlacements();\n        this.reposition(true);\n    }\n    onMessagesChange() {\n        /* wired up by t9n util */\n    }\n    offsetDistanceOffsetHandler() {\n        this.reposition(true);\n    }\n    offsetSkiddingHandler() {\n        this.reposition(true);\n    }\n    openHandler() {\n        onToggleOpenCloseComponent(this);\n        this.reposition(true);\n        this.setExpandedAttr();\n    }\n    overlayPositioningHandler() {\n        this.reposition(true);\n    }\n    placementHandler() {\n        this.reposition(true);\n    }\n    referenceElementHandler() {\n        this.setUpReferenceElement();\n        this.reposition(true);\n    }\n    effectiveLocaleChange() {\n        updateMessages(this, this.effectiveLocale);\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Lifecycle\n    //\n    // --------------------------------------------------------------------------\n    connectedCallback() {\n        this.mutationObserver?.observe(this.el, { childList: true, subtree: true });\n        this.setFilteredPlacements();\n        connectLocalized(this);\n        connectMessages(this);\n        connectFocusTrap(this);\n        // we set up the ref element in the next frame to ensure PopoverManager\n        // event handlers are invoked after connect (mainly for `components` output target)\n        requestAnimationFrame(() => this.setUpReferenceElement(this.hasLoaded));\n    }\n    async componentWillLoad() {\n        await setUpMessages(this);\n        setUpLoadableComponent(this);\n    }\n    componentDidLoad() {\n        setComponentLoaded(this);\n        if (this.referenceElement && !this.effectiveReferenceElement) {\n            this.setUpReferenceElement();\n        }\n        if (this.open) {\n            onToggleOpenCloseComponent(this);\n        }\n        this.hasLoaded = true;\n    }\n    disconnectedCallback() {\n        this.mutationObserver?.disconnect();\n        this.removeReferences();\n        disconnectLocalized(this);\n        disconnectMessages(this);\n        disconnectFloatingUI(this, this.effectiveReferenceElement, this.el);\n        deactivateFocusTrap(this);\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Public Methods\n    //\n    // --------------------------------------------------------------------------\n    /**\n     * Updates the position of the component.\n     *\n     * @param delayed\n     */\n    async reposition(delayed = false) {\n        const { el, effectiveReferenceElement, placement, overlayPositioning, flipDisabled, filteredFlipPlacements, offsetDistance, offsetSkidding, arrowEl, } = this;\n        return reposition(this, {\n            floatingEl: el,\n            referenceEl: effectiveReferenceElement,\n            overlayPositioning,\n            placement,\n            flipDisabled,\n            flipPlacements: filteredFlipPlacements,\n            offsetDistance,\n            offsetSkidding,\n            arrowEl,\n            type: \"popover\",\n        }, delayed);\n    }\n    /**\n     * Sets focus on the component's first focusable element.\n     */\n    async setFocus() {\n        await componentFocusable(this);\n        forceUpdate(this.el);\n        focusFirstTabbable(this.el);\n    }\n    /**\n     * Updates the element(s) that are used within the focus-trap of the component.\n     */\n    async updateFocusTrapElements() {\n        updateFocusTrapElements(this);\n    }\n    getReferenceElement() {\n        const { referenceElement, el } = this;\n        return ((typeof referenceElement === \"string\"\n            ? queryElementRoots(el, { id: referenceElement })\n            : referenceElement) || null);\n    }\n    onBeforeOpen() {\n        this.calcitePopoverBeforeOpen.emit();\n    }\n    onOpen() {\n        this.calcitePopoverOpen.emit();\n        activateFocusTrap(this);\n    }\n    onBeforeClose() {\n        this.calcitePopoverBeforeClose.emit();\n    }\n    onClose() {\n        this.calcitePopoverClose.emit();\n        deactivateFocusTrap(this);\n    }\n    // --------------------------------------------------------------------------\n    //\n    //  Render Methods\n    //\n    // --------------------------------------------------------------------------\n    renderCloseButton() {\n        const { messages, closable } = this;\n        return closable ? (h(\"div\", { class: CSS.closeButtonContainer, key: CSS.closeButtonContainer }, h(\"calcite-action\", { appearance: \"transparent\", class: CSS.closeButton, onClick: this.hide, ref: (closeButtonEl) => (this.closeButtonEl = closeButtonEl), scale: this.scale, text: messages.close }, h(\"calcite-icon\", { icon: \"x\", scale: getIconScale(this.scale) })))) : null;\n    }\n    renderHeader() {\n        const { heading, headingLevel } = this;\n        const headingNode = heading ? (h(Heading, { class: CSS.heading, level: headingLevel }, heading)) : null;\n        return headingNode ? (h(\"div\", { class: CSS.header, key: CSS.header }, headingNode, this.renderCloseButton())) : null;\n    }\n    render() {\n        const { effectiveReferenceElement, heading, label, open, pointerDisabled, floatingLayout } = this;\n        const displayed = effectiveReferenceElement && open;\n        const hidden = !displayed;\n        const arrowNode = !pointerDisabled ? (h(FloatingArrow, { floatingLayout: floatingLayout, key: \"floating-arrow\", ref: this.storeArrowEl })) : null;\n        return (h(Host, { key: 'a563d48090d6e6c0c138023e169667834f657c4c', \"aria-hidden\": toAriaBoolean(hidden), \"aria-label\": label, \"aria-live\": \"polite\", \"calcite-hydrated-hidden\": hidden, id: this.getId(), role: \"dialog\" }, h(\"div\", { key: '73053dbdce2cfc68fcd42667089d611e81010955', class: {\n                [CSS.container]: true,\n                [FloatingCSS.animation]: true,\n                [FloatingCSS.animationActive]: displayed,\n            }, ref: this.setTransitionEl }, arrowNode, h(\"div\", { key: '1fbcd45ee42b10a67881ced74db2db051231c94d', class: {\n                [CSS.hasHeader]: !!heading,\n                [CSS.headerContainer]: true,\n            } }, this.renderHeader(), h(\"div\", { key: '522abe801b98787863aac14d990b948d2d286156', class: CSS.content }, h(\"slot\", { key: '022a8f690288acdbac4ec1b3eccf807ffe382d5d' })), !heading ? this.renderCloseButton() : null))));\n    }\n    static get assetsDirs() { return [\"assets\"]; }\n    get el() { return this; }\n    static get watchers() { return {\n        \"focusTrapDisabled\": [\"handleFocusTrapDisabled\"],\n        \"flipPlacements\": [\"flipPlacementsHandler\"],\n        \"messageOverrides\": [\"onMessagesChange\"],\n        \"offsetDistance\": [\"offsetDistanceOffsetHandler\"],\n        \"offsetSkidding\": [\"offsetSkiddingHandler\"],\n        \"open\": [\"openHandler\"],\n        \"overlayPositioning\": [\"overlayPositioningHandler\"],\n        \"placement\": [\"placementHandler\"],\n        \"referenceElement\": [\"referenceElementHandler\"],\n        \"effectiveLocale\": [\"effectiveLocaleChange\"]\n    }; }\n    static get style() { return CalcitePopoverStyle0; }\n}, [1, \"calcite-popover\", {\n        \"autoClose\": [516, \"auto-close\"],\n        \"closable\": [516],\n        \"flipDisabled\": [516, \"flip-disabled\"],\n        \"focusTrapDisabled\": [516, \"focus-trap-disabled\"],\n        \"pointerDisabled\": [516, \"pointer-disabled\"],\n        \"flipPlacements\": [16],\n        \"heading\": [1],\n        \"headingLevel\": [514, \"heading-level\"],\n        \"label\": [1],\n        \"messageOverrides\": [1040],\n        \"messages\": [1040],\n        \"offsetDistance\": [514, \"offset-distance\"],\n        \"offsetSkidding\": [514, \"offset-skidding\"],\n        \"open\": [1540],\n        \"overlayPositioning\": [513, \"overlay-positioning\"],\n        \"placement\": [513],\n        \"referenceElement\": [1, \"reference-element\"],\n        \"scale\": [513],\n        \"triggerDisabled\": [516, \"trigger-disabled\"],\n        \"effectiveLocale\": [32],\n        \"floatingLayout\": [32],\n        \"effectiveReferenceElement\": [32],\n        \"defaultMessages\": [32],\n        \"reposition\": [64],\n        \"setFocus\": [64],\n        \"updateFocusTrapElements\": [64]\n    }, undefined, {\n        \"focusTrapDisabled\": [\"handleFocusTrapDisabled\"],\n        \"flipPlacements\": [\"flipPlacementsHandler\"],\n        \"messageOverrides\": [\"onMessagesChange\"],\n        \"offsetDistance\": [\"offsetDistanceOffsetHandler\"],\n        \"offsetSkidding\": [\"offsetSkiddingHandler\"],\n        \"open\": [\"openHandler\"],\n        \"overlayPositioning\": [\"overlayPositioningHandler\"],\n        \"placement\": [\"placementHandler\"],\n        \"referenceElement\": [\"referenceElementHandler\"],\n        \"effectiveLocale\": [\"effectiveLocaleChange\"]\n    }]);\nfunction defineCustomElement() {\n    if (typeof customElements === \"undefined\") {\n        return;\n    }\n    const components = [\"calcite-popover\", \"calcite-action\", \"calcite-icon\", \"calcite-loader\"];\n    components.forEach(tagName => { switch (tagName) {\n        case \"calcite-popover\":\n            if (!customElements.get(tagName)) {\n                customElements.define(tagName, Popover);\n            }\n            break;\n        case \"calcite-action\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$3();\n            }\n            break;\n        case \"calcite-icon\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$2();\n            }\n            break;\n        case \"calcite-loader\":\n            if (!customElements.get(tagName)) {\n                defineCustomElement$1();\n            }\n            break;\n    } });\n}\ndefineCustomElement();\n\nexport { Popover as P, defineCustomElement as d };\n\n//# sourceMappingURL=popover.js.map"],"names":["Heading","props","children","HeadingTag","level","h","class","key","CSS","SLOTS","tooltip","trigger","ICONS","SUPPORTED_MENU_NAV_KEYS","ActionMenu","constructor","super","this","__registerHost","__attachShadow","calciteActionMenuOpen","actionElements","guid","g","menuId","menuButtonId","connectMenuButtonEl","open","label","menuButtonEl","slottedMenuButtonEl","defaultMenuButtonEl","disconnectMenuButtonEl","setTooltipReferenceElement","active","setAttribute","t","id","text","addEventListener","menuButtonClick","menuButtonKeyDown","removeEventListener","setMenuButtonEl","event","actions","target","assignedElements","flatten","filter","el","matches","setDefaultMenuButtonEl","handleCalciteActionClick","setFocus","toggleOpen","updateTooltip","tooltips","tooltipEl","expanded","referenceElement","updateAction","action","index","activeMenuItemIndex","tabIndex","toggleAttribute","updateActions","forEach","handleDefaultSlotChange","reduce","previousValue","currentValue","push","concat","Array","from","querySelectorAll","disabled","hidden","length","i","preventDefault","click","handleActionNavigation","isValidKey","currentIndex","Math","max","toggleOpenEnd","value","handlePopoverOpen","handlePopoverClose","appearance","flipPlacements","undefined","overlayPositioning","placement","scale","connectedCallback","componentWillLoad","s","componentDidLoad","disconnectedCallback","expandedHandler","openHandler","emit","activeMenuItemIndexHandler","c","renderMenuButton","name","onSlotchange","icon","ref","textEnabled","renderMenuItems","activeAction","activeDescendantId","autoClose","focusTrapDisabled","offsetDistance","onCalcitePopoverClose","onCalcitePopoverOpen","pointerDisabled","onClick","role","render","supportedKeys","find","k","watchers","style","defineCustomElement","customElements","tagName","get","define","d","_defineProperty","e","r","Symbol","toPrimitive","call","TypeError","String","Number","_toPrimitive","_toPropertyKey","Object","defineProperty","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","o","getOwnPropertyDescriptor","apply","_objectSpread2","arguments","getOwnPropertyDescriptors","defineProperties","activeFocusTraps","trapStack","trap","activeTrap","pause","trapIndex","indexOf","splice","unpause","isTabEvent","keyCode","isKeyForward","shiftKey","isKeyBackward","delay","fn","setTimeout","findIndex","arr","idx","every","valueOrHandler","_len","params","_key","getActualTarget","shadowRoot","composedPath","internalTrapStack","createFocusTrap","elements","userOptions","doc","document","config","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","state","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","paused","delayInitialFocusTimer","recentNavEvent","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","element","_ref","container","tabbableNodes","contains","includes","node","getNodeForOption","optionValue","_len2","_key2","Error","querySelector","getInitialFocusNode","tabbableOptions","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","map","focusableNodes","lastTabbableNode","firstDomTabbableNode","lastDomTabbableNode","slice","reverse","posTabIndexesFound","nextTabbableNode","forward","nodeIdx","group","_getActiveElement","_tryFocus","focus","preventScroll","toLowerCase","select","isSelectableInput","getReturnFocusNode","previousActiveElement","findNextNavNode","_ref2","_ref2$isBackward","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","_ref3","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref4","_destinationGroupIndex","_destinationGroup","checkPointerDown","clickOutsideDeactivates","deactivate","returnFocus","allowOutsideClick","checkFocusIn","targetContained","Document","nextNode","stopImmediatePropagation","navAcrossContainers","mruContainerIdx","mruTabIdx","some","n","checkTabKey","checkKeyNav","checkEscapeKey","checkClick","addListeners","capture","passive","removeListeners","mutationObserver","window","MutationObserver","mutations","mutation","removedNodes","updateObservedNodes","disconnect","observe","subtree","childList","activate","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","options","onDeactivate","onPostDeactivate","checkCanReturnFocus","clearTimeout","finishDeactivation","pauseOptions","onPause","onPostPause","unpauseOptions","onUnpause","onPostUnpause","updateContainerElements","containerElements","elementsAsArray","Boolean","connectFocusTrap","component","focusTrapNode","focusTrapEl","focusTrapOptions","fallbackFocus","setReturnFocus","ownerDocument","f","focusTrap","activateFocusTrap","deactivateFocusTrap","updateFocusTrapElements","ARIA_CONTROLS","ARIA_EXPANDED","manager","registeredElements","Map","registeredElementCount","queryPopover","registeredElement","pathEl","has","togglePopovers","togglePopover","triggerDisabled","values","popover","keyDownHandler","defaultPrevented","closeAllPopovers","clickHandler","registerElement","referenceEl","set","unregisterElement","delete","Popover","calcitePopoverBeforeClose","calcitePopoverClose","calcitePopoverBeforeOpen","calcitePopoverOpen","openTransitionProp","hasLoaded","setTransitionEl","transitionEl","setFilteredPlacements","filteredFlipPlacements","setUpReferenceElement","warn","removeReferences","effectiveReferenceElement","getReferenceElement","addReferences","getId","setExpandedAttr","removeAttribute","hide","storeArrowEl","arrowEl","reposition","closable","flipDisabled","heading","headingLevel","messageOverrides","messages","offsetSkidding","effectiveLocale","floatingLayout","defaultMessages","handleFocusTrapDisabled","a","flipPlacementsHandler","onMessagesChange","offsetDistanceOffsetHandler","offsetSkiddingHandler","overlayPositioningHandler","placementHandler","referenceElementHandler","effectiveLocaleChange","u","requestAnimationFrame","delayed","floatingEl","type","q","onBeforeOpen","onOpen","onBeforeClose","onClose","renderCloseButton","closeButtonEl","close","renderHeader","headingNode","H","displayed","arrowNode","F","animation","animationActive","assetsDirs"],"sourceRoot":""}